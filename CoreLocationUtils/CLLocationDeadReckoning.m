//
//  CLLocationDeadReckoning.m
//  StreetWise
//
//  Created by Rotem Rubnov on 22/6/2011.
//  Copyright 2011 100 grams. All rights reserved.
//

#import "CLLocationDeadReckoning.h"
#import "CLLocation+measuring.h"
#import "CLLocation+routeInfo.h"
#import "CLLocationDispatch.h"

#define drOffRouteThreshold 50 //meters

@interface CLLocationDeadReckoning(internal)
- (void) generateLocation;
- (void) startOnMainThread;
@end

@implementation CLLocationDeadReckoning

@synthesize drLocations=_drLocations;
@synthesize followRoute;
@synthesize deadReckoningInterval;
@synthesize maxGeneratedLocationsLimit;

- (id) init
{
    self = [super init];
    if(self){
        self.maxGeneratedLocationsLimit = -1; //by default do not limit number of generated soft-locations
        self.deadReckoningInterval = 1.0; //seconds
        _drLocations = [[NSMutableArray alloc] initWithCapacity:0];
    }
    return self;
}

#if !__has_feature(objc_arc)
- (void) dealloc
{
    [_locationsTimer invalidate]; _locationsTimer = nil;
    [_drLocations release]; _drLocations=nil;
    self.followRoute = nil;
    [super dealloc];
}
#endif

- (void) startWithRoute:(NSArray*)route;
{
    if (_locationsTimer) {
        [self stop];
    }
    self.followRoute = route; 
    
    if ([NSThread isMainThread]) {
        [self startOnMainThread];
    }
    else{
        [self performSelectorOnMainThread:@selector(startOnMainThread) withObject:nil waitUntilDone:NO];        
    }
  
}

- (void) startOnMainThread
{
    [[CLLocationDispatch sharedDispatch] addListener:self];
    
    _locationsTimer = [NSTimer scheduledTimerWithTimeInterval:self.deadReckoningInterval target:self selector:@selector(generateLocation) userInfo:nil repeats:TRUE];
    [[NSRunLoop mainRunLoop] addTimer:_locationsTimer forMode:NSDefaultRunLoopMode];
    
}

- (void) stop;
{
    self.followRoute = nil;
    [[CLLocationDispatch sharedDispatch] removeListener:self];
    [_locationsTimer invalidate];
    _locationsTimer = nil; 
}

#pragma mark - Dead Reckoning


- (void) generateLocation
{
    if (!_newLocation || _newLocation.speed < 0) {
        NSLog(@"cannot generateLocation: NO SPEED!");
        return; //cannot dead reckon
    }
    
    // check timestamp of last location. If more than kGeneratedLocationInterval seconds have passed, generate a soft location.
    NSDate *lastReportedLocationTime = _newLocation.timestamp; 
//    NSTimeInterval elapsedTime;
//    // if we're running a demo, the location timestamps are in the past. Translate them to present 
//    // to calculate the time delta between now and the last reported location. 
//    // Note: last reported location can also be a soft-location, generated by this method.
//    if (self.isRunningDemo) {
//        NSDate *logStartDate = ((CLLocation*)[_locations objectAtIndex:_startIndexForPlayingLog]).timestamp;
//        elapsedTime = [self.newLocation.timestamp timeIntervalSinceDate:logStartDate]; // elapsed time from log start to last location update
//        lastReportedLocationTime = [NSDate dateWithTimeInterval:elapsedTime sinceDate:playLogStartDate]; // shift timestamp of last location reported to "now".
//    }
    NSDate *now = [NSDate dateWithTimeIntervalSinceNow:0];
    NSTimeInterval delta = [now timeIntervalSinceDate:lastReportedLocationTime];
    
    if (delta >= 0.99 * self.deadReckoningInterval ) {
        if (_newLocation.speed == 0) {
            NSLog(@"dead-reckoning: speed is 0. Stopping...");
            [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationStoppedDR object:self userInfo:nil];
        }
        else if([self.drLocations count] >= self.maxGeneratedLocationsLimit){
            NSLog(@"dead-reckoning: generated %d locations, this is the maximum allowed. Stopping...", self.maxGeneratedLocationsLimit);
            [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationStoppedDR object:self userInfo:nil];
        }
        else{
            // adjust the speed for deceleration and excessive speed jumps
            NSTimeInterval tInterval = [_newLocation.timestamp timeIntervalSinceDate:_oldLocation.timestamp];
            CLLocationSpeed adjustedSpeed = _newLocation.speed;
            if ([self.drLocations count] == 0) {
                _deceleration = (_newLocation.speed - _oldLocation.speed) / tInterval;
            }
            if (_deceleration <= 0) {
                adjustedSpeed = ((CLLocation*)[self.drLocations lastObject]).speed + _deceleration*tInterval;
            }
//            else if(_deceleration>2.0){
//                adjustedSpeed = _newLocation.speed * 0.8;
//            }
            if (adjustedSpeed <= 0) {
                NSLog(@"dead-reckoning: adjustedSpeed is now %fm/s (deceleration %f). Stopping...", adjustedSpeed, _deceleration);
                [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationStoppedDR object:self userInfo:nil];
            }
            else{
                
                // dead-reckon a new soft location from calculated speed and course
                CLLocation *newDR = [_newLocation newLocationAfterMovingAtSpeed:adjustedSpeed duration:delta direction:_newLocation.course];
                CLLocation *nearestRouteNode, *nearestLocationOnRoute;
                NSInteger nodeIndexAfter;
                CLLocationDistance distance = [newDR distanceFromRoute:self.followRoute nearestNodeFound:&nearestRouteNode nearestLocationOnRoute:&nearestLocationOnRoute nodeIndexAfterIntersection:&nodeIndexAfter];
                
                if (distance > drOffRouteThreshold) {
                    NSLog(@"DR is off route by %f meteres. Stopping...", distance);
                    [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationStoppedDR object:self userInfo:nil];
                }
                else{
                    // finally create the route-matched DR location. 
                    // Note: taking the approximate course from the nearest route node
                    CLLocation *routeMatchedDR = [[CLLocation alloc] initWithCoordinate:nearestLocationOnRoute.coordinate altitude:newDR.altitude horizontalAccuracy:newDR.horizontalAccuracy verticalAccuracy:newDR.verticalAccuracy course:nearestRouteNode.course speed:newDR.speed timestamp:newDR.timestamp] ;
                    
                    [_drLocations addObject:routeMatchedDR];
                    NSLog(@"dead-reckoning: %@", routeMatchedDR);        
                    //                [self locationManager:nil didUpdateToLocation:softLocation fromLocation:self.newLocation];
                    
                    // report the DR location 
                    [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationNewDRLocation object:self userInfo:nil];
                    
                    Release(routeMatchedDR);
                }
                Release(newDR);
            }
        }
        
    }
    else{
        NSLog(@"dead-reckoning: last hard location received %f secs ago. Skipping...", delta);
    }
}


#pragma mark - CLLocationManagerDelegate

- (void) locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation
{
#if !__has_feature(objc_arc)
    [_oldLocation release];
    _oldLocation = [oldLocation retain];
    [_newLocation release];
    _newLocation = [newLocation retain];
#else
    _oldLocation = oldLocation;
    _newLocation = newLocation;
#endif
    
    [_drLocations removeAllObjects];
}

@end
